# V Review (2022)

[V](https://vlang.io/) is a programming language promising to be "Simple, fast, safe, compiled. For developing maintainable software.".
V has a [controversial](https://christine.website/blog/v-vaporware-2019-06-23) [past](https://christine.website/blog/v-vvork-in-progress-2020-01-03) but what is the state of V in 2022?

Is V worth checking out? 

In this post, we'll take a look at V as it exists in May 2022. 

## Rules of engagement

I'll be using the current version of V built from git which is [`50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6`](https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6).

To evaluate the language, I'll validate the claims made on their homepage and related sub-pages/documentation.
Where possible, I'll try to include the code used to evalute a claim.

## Evaluation

### Simple language for building maintainable programs

I don't see any objective way to evaluate the claims in this section, so we'll give them a pass.

*Evaluation*: N/a

### Safety

> No null

The [V docs](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md) indicate V has references and "in general, V's references are similar to Go pointers and C++ references".

Let's see if we can pass a null reference to a function.
The docs contain an example of a tree structure, so let's adapt that and see if we can create a null reference.
Null usually corresponds to `0` so we'll try that:

```v
struct Node {
        val   int
        left  &Node
        right &Node
}

fn main() {
        n := Node { 123, 0, 0 }
        println(n.left)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.2938032035736349851.tmp.c:6750: at print_backtrace: Backtrace
/tmp/v_1000/test.2938032035736349851.tmp.c:6821: by v_segmentation_fault_handler
7f6ff9bfe210 : by ???
/tmp/v_1000/test.2938032035736349851.tmp.c:11990: by main
```

Oh, no. ðŸ˜°
Let's check the generated C and *see* what's up:

```c
...
struct main__Node {
        int val;
        main__Node* left;
        main__Node* right;
};
...
VV_LOCAL_SYMBOL void main__main(void) {
        main__Node n = ((main__Node){.val = 123,.left = 0,.right = 0,});
        println(str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s=main__Node_str(*n.left)}}})));
}
...
```

So yeah, we're able to create a null pointer (V reference) with no compiler errors or warnings.

*Evaluation*: ðŸ›‘ Doesn't seem to hold up

# V Review (2022)

[V](https://vlang.io/) is a programming language promising to be "Simple, fast, safe, compiled. For developing maintainable software.".
V has a [controversial](https://christine.website/blog/v-vaporware-2019-06-23) [past](https://christine.website/blog/v-vvork-in-progress-2020-01-03) but what is the state of V in 2022?

Is V worth checking out? 

In this post, we'll take a look at V as it exists in May 2022. 

## Rules of engagement

I'll be using the current version of V built from git which is [`50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6`](https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6).
I'll also stick to the compiler defaults as much as possible to keep to the ["happy path"](https://en.wikipedia.org/wiki/Happy_path) so that I get a typical V experience.

To evaluate the language, I'll validate the major claims made on their homepage and related sub-pages/documentation.
Features indicated to be incomplete/work in progress/unimplemented will be mentioned as such.
Where possible, I'll try to include the code used to evalute a claim.

I'm also scoping this to focus on V the language and not any of the standard libraries or other related projects as V seems to be the most developed.

## Evaluation

### Simple language for building maintainable programs

I don't see any objective way to evaluate the claims in this section, so we'll give them a pass.

*Evaluation*: N/a

### Safety

> - No null

The [V docs](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md) indicate V has references and "in general, V's references are similar to Go pointers and C++ references".

Let's see if we can pass a null reference to a function.
The docs contain an example of a tree structure, so let's adapt that and see if we can create a null reference.
Null usually corresponds to `0` so we'll try that:

```v
struct Node {
    val   int
    left  &Node
    right &Node
}

fn main() {
    n := Node { 123, 0, 0 }
    println(n.left)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.2938032035736349851.tmp.c:6750: at print_backtrace: Backtrace
/tmp/v_1000/test.2938032035736349851.tmp.c:6821: by v_segmentation_fault_handler
7f6ff9bfe210 : by ???
/tmp/v_1000/test.2938032035736349851.tmp.c:11990: by main
```

Oh, no. 😰
Let's check the generated C and *see* what's up:

```c
...
struct main__Node {
    int val;
    main__Node* left;
    main__Node* right;
};
...
VV_LOCAL_SYMBOL void main__main(void) {
    main__Node n = ((main__Node){.val = 123,.left = 0,.right = 0,});
    println(str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s=main__Node_str(*n.left)}}})));
}
...
```

So yeah, we're able to create a null pointer (V reference) with no compiler errors or warnings.

*Evaluation*: 🛑 Doesn't seem to hold up

> - No undefined values

It's not obvious to me what this means.
Javascript has a [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) value but that doesn't really seem relevant.
C allows you to use an uninitialized variable which can result in Undefined Behavior.
I'll assume that's what this means.

Typically, uninitalized values come from a memory allocation that hasn't been written to.
The [V docs say](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md#array-initialization) we can create an empty array by passing the allocation length in the initialization expression.
Let's see if we can get the V compiler to allocate memory for us without writting to it:

```v
fn main() {
    a := []&int { len: 1 }
    println(a)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.926306498470184027.tmp.c:6770: at print_backtrace: Backtrace
/tmp/v_1000/test.926306498470184027.tmp.c:6841: by v_segmentation_fault_handler
7fc58f7fd210 : by ???
/tmp/v_1000/test.926306498470184027.tmp.c:1973: by Array_main__Node_ptr_str
/tmp/v_1000/test.926306498470184027.tmp.c:11644: by main__main
/tmp/v_1000/test.926306498470184027.tmp.c:12010: by main
```

Sigh.
The generated C code is 12,000 lines long and nothing jumps out to me with a quick glance, so I won't try to dig in further. 

*Evaluation*: 🛑 Doesn't seem to hold up

> - No undefined behavior

Wikipedia [has a list](https://en.wikipedia.org/wiki/Undefined_behavior#Examples_in_C_and_C++) of Undefined Behaviors (UB) in C and C++.
Let's see if we can get V to generate C code which contains some of these behaviors!

- Integer Overflow

In C and C++, signed integer overflow results in UB.
Let's try to add `1` to the max value of an integer and see what happens:

```v
fn main() {
    x := i32(2147483647) + 1
    println(x)
}
```

```
$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
test.c: In function ‘main__main’:
test.c:11605:30: warning: integer overflow in expression of type ‘int’ results in ‘-2147483648’ [-Woverflow]
11605 |  int x = ((i32)(2147483647)) + 1;
      |                              ^
$ ./a.out
test.c:7248:33: runtime error: signed integer overflow: -2147483648 - 2147483600 cannot be represented in type 'int'
-2147483648
```

That's no good.

Let's try some of the other classic cases of UB.

- Divide by 0

```v
fn main() {
    x := 42
    y := 0
    z := x / y
    println(z)
}
```

```
$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
$ ./a.out
test.c:11607:12: runtime error: division by zero
Floating point exception
```

- Temporal memory safety violations (dangling pointer)

```v
struct Something {
    val   int
}

fn main() {
    x := voidptr(123)
    y := &Something(x)
    println(y)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.5460990319614516137.tmp.c:6746: at print_backtrace: Backtrace
/tmp/v_1000/test.5460990319614516137.tmp.c:6817: by v_segmentation_fault_handler
7f062f88d210 : by ???
/tmp/v_1000/test.5460990319614516137.tmp.c:11987: by main
```

There's more UB we could test for but I'm just going to call it there.

*Evaluation*: 🛑 Doesn't seem to hold up

> - No variable shadowing

I don't see how variable shadowing is a safety issue and shadowing variables after they should no longer be used in a common technique in functional programming languages but let's test it out:

```v
fn main() {
    x := 1
    x := 2

    if true {
        x := 3
    }
}
```

```
$ ./v run test.v
test.v:3:2: error: redefinition of `x`
    1 | fn main() {
    2 |     x := 1
    3 |     x := 2
      |     ^
    4 |
    5 |     if true {
```

and removing that line:

```
$ ./v run test.v
test.v:5:3: error: redefinition of `x`
    3 |
    4 |     if true {
    5 |         x := 3
      |         ^
    6 |     }
    7 | }
```

Works as advertised! ✔️

I see though that V supports closures.
What are the rules for shadowing variables in closures?

```v
fn main() {
    x := 1

    y := fn (x int) {
        println(x)
    }

    y(x)
    y(2)
}
```

```
$ ./v run test.v
1
2
```

It looks like shadowing is allowed for closure arguments? 
There are also explicit closure captures, what happens if I also capture `x`?

```v
$ cat test.v
fn main() {
    x := 1

    y := fn [x] (x int) {
        println(x)
    }

    y(x)
    y(2)
}
```

```
$ ./v run test.v
1
1
```

Well, that seems like it should be disallowed.
It makes sense that `x` can be captured but to then shadow the argument with the same name without error or warning doesn't seem inline with the rest of V's behavior.

Even with this surprising behavior, I'm going to give it to V.

*Evaluation*: ✔️ Seems to work

> - Bounds checking

Bounds checking is important to prevent out-of-bounds access to arrays.

Let's check a simple example:

```v
fn main() {
    x := [1, 2, 3]
    println(x[4])
}
```

```
$ ./v run test.v
V panic: array.get: index out of range (i == 4, a.len == 3)
v hash: 50ab2cf
/tmp/v_1000/test.17032083146791375427.tmp.c:6344: at _v_panic: Backtrace
/tmp/v_1000/test.17032083146791375427.tmp.c:5860: by array_get
/tmp/v_1000/test.17032083146791375427.tmp.c:11597: by main__main
/tmp/v_1000/test.17032083146791375427.tmp.c:11963: by main
```

Seeing `a.len == 3` reminds me that V allows you to mess with some of the array (vector) properties at creation:

```v
fn main() {
    x := []&int { len: 10, cap: 0 }
    println(x[4])
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.8104236387804386445.tmp.c:6724: at print_backtrace: Backtrace
/tmp/v_1000/test.8104236387804386445.tmp.c:6795: by v_segmentation_fault_handler
7f8aa2432210 : by ???
/tmp/v_1000/test.8104236387804386445.tmp.c:11964: by main
```

Allowing the user to control the `len` property is a **really** bad idea.

*Evaluation*: ⚠️ Some basic checking exists but can be trivially bypassed

> - Immutable variables by default

Immutable values by default is a good default in a modern programming language.

```v
fn main() {
    x := 4
    x = 2
}
```

```
$ ./v run test.v
test.v:2:2: warning: unused variable: `x`
    1 | fn main() {
    2 |     x := 4
      |     ^
    3 |     x = 2
    4 | }
test.v:3:2: error: `x` is immutable, declare it with `mut` to make it mutable
    1 | fn main() {
    2 |     x := 4
    3 |     x = 2
      |     ^
    4 | }
```

So far so good!
V seems to be pretty loose with typecasts though so can we trick the compiler into letting us mutate an immutable value?
Yes, we can:

```v
[heap]
struct Foo {
    mut: value int
}

fn y(x &Foo) {
    mut m := x
    m.value = 42
}

fn main() {
    x := Foo { 123 }
    y(x)
    println(x)
}
```

```
$ ./v run test.v
Foo{
    value: 42
}
```

You really shouldn't be able to convert the immutable reference to a mutable one (`mut m := x`).
This results in us being able to mutate the "immutable" value `x` in `main` with no indication at the call site, there's not even the clue that we're passing the value by reference.

*Evaluation*: 🛑 Variables aren't immutable in any significant way because you can trivially turn an immutable reference into a mutable one.

> - Pure functions by default

The [docs say](https://github.com/vlang/v/blob/master/doc/docs.md#pure-functions-by-default):

> V functions are pure by default, meaning that their return values are a function of their arguments only, and their evaluation has no side effects (besides I/O).

**besides I/O**

[wat](https://www.destroyallsoftware.com/talks/wat)

I/O is [literally the definition of an impure operation](https://en.wikipedia.org/wiki/Pure_function#I/O_in_pure_functions) because it allows a function to trivially break referential transparency which V claims to uphold ("their {V functions} return values are a function of their arguments only").

> This is achieved by a lack of global variables and all function arguments being immutable by default, even when references are passed.

As we saw in the previous section, immutability in V is broken so this guarantee doesn't hold.

To demonstrate how completely ludicrous this definition is, here is a "pure" V module that re-implements global variables using file I/O:

```v
import os

fn read_global(name string) int {
    content := os.read_file(name) or { return 0 }
    return content.int()
}

fn write_global(name string, value int) {
    s := value.str()
    os.write_file(name, s) or { }
}
```

and we'll go ahead and use it:

```v
import globals

fn x() {
    globals.write_global("my_global", 7)
}

fn y() {
    my_global := globals.read_global("my_global")
    globals.write_global("my_global", my_global * 3)
}

fn z() int {
    my_global := globals.read_global("my_global")
    globals.write_global("my_global", my_global * 2)
    return globals.read_global("my_global")
}

fn main() {
    x()
    y()
    my_global := z()
    println(my_global)
}
```

```
$ ./v run test.v
42
```

*Evaluation*: 🛑 Claim is meaningless as it redefines "pure" to mean "impure"

> Immutable structs by default

We've already broke immutable values in a previous section using structs so we know this doesn't hold.

*Evaluation*: 🛑 Doesn't seem to hold

> - Option/Result and mandatory error checks

Mandatory error checks seem to work correctly in most contexts.
Is it possible to confuse the compiler and have it ignore the return value?

```v
fn ignore(x any) {
}

fn create_error() ?int {
    return error("an error")
}

fn main() {
    ignore(create_error())
}
```

```
$ ./v run test.v
test.v:9:9: error: create_error() returns an option, so it should have either an `or {}` block, or `?` at the end
    7 |
    8 | fn main() {
    9 |     ignore(create_error())
      |            ~~~~~~~~~~~~~~
   10 | }
```

Looks good! 
I tried a few different variations on this idea but wasn't able to confuse the compiler.

*Evaluation*: ✔️ Works as advertised

> - Sum types

Sum types are a very nice feature!
Let's see how they work:

```v
type MyType = f64 | i64

fn test(x MyType) {
    println(x)
}

fn main() {
    test(i64(0))
}
```

```
$ ./v run test.v
MyType(0)
```

Good!
The implementation seems pretty fragile though.
Many operations that are allowed for normal types, seem to crash the compiler when used with sumtypes.
For instance, casting:

```v
type MyType = f64 | i64

fn test(x MyType) {
    println(i64(x))
}

fn main() {
    test(i64(0))
}
```

```
$ ./v run test.v
==================
/tmp/v_1000/test.11297848884384464859.tmp.c:11633: error: cannot convert 'struct main__MyType' to 'long'
...
==================
(Use `v -cg` to print the entire error message)

builder error:
==================
C error. This should never happen.

This is a compiler bug, please report it using `v bug file.v`.

https://github.com/vlang/v/issues/new/choose

You can also use #help on Discord: https://discord.gg/vlang
```

Sum types have some restrictions:

```v
type MyType = &i64 | &f64

fn main() {
}
```

```
$ ./v run test.v
test.v:1:15: error: sum type cannot hold a reference type
    1 | type MyType = &i64 | &f64
      |               ~~~~
    2 |
    3 | fn main() {
```

but they don't seem to be well checked 😢:

```v
type MyType = Foo | Bar
type Foo = &i64
type Bar = &f64

fn main() {
}
```

```
$ ./v run test.v
$ echo $?
0
```

*Evaluation*: ⚠️ Sum types generally seem to work but there are implementation issues.

> - Generics

V generics are a little strange.
They're much more like C++ templates than they are generics as known from Java, C#, ML, Rust, etc.
V doesn't have a way to restrict the set of types allowed to be substituted (`where T: IInterface` in C#) which means the compiler can't check generic code at declaration time:

```v
fn foo<T>(x T) {
        this_func_does_not_exist(x)
        what.the.f = "wut"
        x.not_a_real_method()
}

fn main() {
}
```

```
$ ./v run test.v
$ echo $?
0
```

Even though V ~generics~ templates are conceptually similar to C++ templates, the lack of [SFINAE](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error) seems to lead to compiler crashes:

```v
struct Wrapped<T> {
    value T
}

fn (w Wrapped<T>) double() Wrapped<T> {
    return Wrapped<T> { w.value * 2 }
}

fn make_wrapped<T>(value T) Wrapped<T> {
    return Wrapped<T> { value }
}

fn main() {
    println(make_wrapped("str"))
}
```

```
$ ./v run test.v
==================
/tmp/v_1000/test.6663405339574001690.tmp.c:11622: error: invalid operand types for binary operation
/tmp/v_1000/test.6663405339574001690.tmp.c:11622: error: invalid aggregate type for register load
...
==================
(Use `v -cg` to print the entire error message)

builder error:
==================
C error. This should never happen.

This is a compiler bug, please report it using `v bug file.v`.

https://github.com/vlang/v/issues/new/choose

You can also use #help on Discord: https://discord.gg/vlang
```

V's decision here requires stamping out ([monomorphisizing](https://en.wikipedia.org/wiki/Monomorphization)) functions for all concrete instances of templated types used in the program.
In C++, this generally leads to "template bloat" as often many monomorphic instances of a templated function can share code.
While the effects on code size can often be resolved via link-time optimizations, this can significantly hurt compile times. 
Given V's desire for *extremely* fast compile times, this is probably not a good strategy for the long term as it requires both V's compiler to type-check each copy of the function separately as well as the C compiler to compile each instantiation as well. 

The V compiler doesn't seem to prevent the "mangled" templated type names from colliding with user defined type names either:

```v
struct MyStruct<T> {
    val T
}

struct Foo {
    x int
}

struct MyStruct_T_main__Foo {
    bla string
}

fn main() {
    x := MyStruct<Foo> { Foo { 0 } }
    y := MyStruct_T_main__Foo { "" }
    println(x)
    println(y)
}
```

```
$ ./v run test.v
==================
/tmp/v_1000/test.5104305706961604858.tmp.c:1112: error: struct/union/enum already defined
...
==================
(Use `v -cg` to print the entire error message)

builder error:
==================
C error. This should never happen.

This is a compiler bug, please report it using `v bug file.v`.

https://github.com/vlang/v/issues/new/choose

You can also use #help on Discord: https://discord.gg/vlang
```

I'm very torn on evaluating this feature.
On the one hand, basic usage seems to work.
On the other hand, the implementation seems to be little more than textual substitution and bears no real relation to the generics of other programming languages (Go included!).

*Evaluation*: 🛑 A basic implementation exists but is very buggy and seems completely out of place in a language with an self described emphasis on safety and compiler performance.

> - No global variables (can be enabled for low level applications like kernels via a command line flag)

By default, V doesn't allow global variables.

```v
__global(
    x = i64(42)
)

fn main() {
}
```

```
$ ./v run test.v
test.v:1:1: error: use `v -enable-globals ...` to enable globals
    1 | __global(
      | ~~~~~~~~
    2 |     x = i64(42)
    3 | )
```

*Evaluation*: ✔️ Works as advertised!

### Performance

> - As fast as C (V's main backend compiles to human readable C)

To start, I'll preface this by saying that comparing programming languages on the basis of performance is extremely difficult.
There are many factors and tradeoffs which have to be weighed for a complete comparison.
No individual benchmark or measurement will be perfect and results can vary widely from one machine to another.

I think it's also important to point out that compiling to C does not automatically make your language fast and specifically it does not automatically give you C level performance.
To see this statement being used to justify the performance claim is frankly shocking.

As a novice V programmer, I can't claim to be able to write fast V code.
I will therefore lean on community benchmarks where interested parties can battle it out themselves.

First up, let's look at [`kostya/benchmarks`](https://github.com/kostya/benchmarks).
Let's check out [V vs C](https://programming-language-benchmarks.vercel.app/v-vs-c).
For each benchmark that has both a C entry and a V entry, we'll compare the fastest versions of each language:

| Benchmark | Fastest V time | Fastest C time | V delta |
| - | - | - | - |
| helloworld | 1.5ms | 1.5ms | Equal |
| nbody | 988ms | 321ms | 3.1x slower 🔻 |
| nsieve | 509ms | 795ms | 1.5% faster ⬆️ |
| spectral-norm | 4117ms | 1406ms | 2.9x slower 🔻 |

It seems early to draw conclusions from so few data points, but this doesn't look good for V.
C is missing from quite a few of these benchmarks which makes it difficult to draw a conclusion.
Rust has many more of these benchmarks implemented and is considered to be on par with C for performance, so let's look at those:

| Benchmark | Fastest V time | Fastest Rust time | V delta |
| - | - | - | - |
| binarytrees | 1118ms | 1792ms | 1.6x faster ⬆️ |
| coro-prime-sieve | 2078ms | 74ms | 28.1x slower 🔻 |
| edigits | *timeout* | 147ms | *Significantly* slower 🔻 |
| fannkuch-redux | 3311ms | 726ms | 4.6x slower 🔻 |
| fasta | 769ms | 180ms | 4.3x slower 🔻 |
| helloworld | 1.5ms | 2.1ms | 1.4x faster ⬆️ |
| lru | 399ms | 53ms | 7.5x slower 🔻 |
| nbody | 988ms | 253ms | 3.9x slower 🔻 |
| nsieve | 509ms | 465ms | 1.1x slower 🔻 |
| pidigits | 4672ms | 1829ms | 2.6x slower 🔻 |
| spectral-norm | 4117ms | 1065ms | 3.9x slower 🔻 |

So V doesn't seem to even be close to either C or Rust in these benchmarks.
Perhaps we should try looking at higher-level language that doesn't offer as much control as C and Rust aim to: C#.

| Benchmark | Fastest V time | Fastest C# time | V delta |
| - | - | - | - |
| binarytrees | 1118ms | 1400ms | 1.3x faster ⬆️ |
| coro-prime-sieve | 2078ms | 410ms | 5.1x slower 🔻 |
| edigits | *timeout* | 1112ms | *Significantly* slower 🔻 |
| fasta | 769ms | 386ms | 2.0x slower 🔻 |
| helloworld | 1.5ms | 19ms | 12.7x faster ⬆️ |
| lru | 399ms | 187ms | 2.1x slower 🔻 |
| nbody | 988ms | 438ms | 2.3x slower 🔻
| nsieve | 509ms | 910ms | 1.8x faster ⬆️ |
| pidigits | 4672ms | *timeout* | *Significantly* faster ⬆️ |
| spectral-norm | 4117ms | 2999ms | 1.4x slower 🔻 |

This seems like a much more mixed result and so I think it would be fair to say V is more competitive with a language like C# or Java than C.

If V was closer with either of C or Rust, I'd be interested to investigate more deeply but as it stands, I think it's safe to say:

*Evaluation*: 🛑 V's performance claims don't seem to be valid

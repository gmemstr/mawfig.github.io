# V Review (2022)

[V](https://vlang.io/) is a programming language promising to be "Simple, fast, safe, compiled. For developing maintainable software.".
V has a [controversial](https://christine.website/blog/v-vaporware-2019-06-23) [past](https://christine.website/blog/v-vvork-in-progress-2020-01-03) but what is the state of V in 2022?

Is V worth checking out? 

In this post, we'll take a look at V as it exists in May 2022. 

## Rules of engagement

I'll be using the current version of V built from git which is [`50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6`](https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6).
I'll also stick to the compiler defaults as much as possible to keep to the ["happy path"](https://en.wikipedia.org/wiki/Happy_path) so that I get a typical V experience.

To evaluate the language, I'll validate the claims made on their homepage and related sub-pages/documentation.
Where possible, I'll try to include the code used to evalute a claim.

## Evaluation

### Simple language for building maintainable programs

I don't see any objective way to evaluate the claims in this section, so we'll give them a pass.

*Evaluation*: N/a

### Safety

> No null

The [V docs](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md) indicate V has references and "in general, V's references are similar to Go pointers and C++ references".

Let's see if we can pass a null reference to a function.
The docs contain an example of a tree structure, so let's adapt that and see if we can create a null reference.
Null usually corresponds to `0` so we'll try that:

```v
struct Node {
        val   int
        left  &Node
        right &Node
}

fn main() {
        n := Node { 123, 0, 0 }
        println(n.left)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.2938032035736349851.tmp.c:6750: at print_backtrace: Backtrace
/tmp/v_1000/test.2938032035736349851.tmp.c:6821: by v_segmentation_fault_handler
7f6ff9bfe210 : by ???
/tmp/v_1000/test.2938032035736349851.tmp.c:11990: by main
```

Oh, no. ðŸ˜°
Let's check the generated C and *see* what's up:

```c
...
struct main__Node {
        int val;
        main__Node* left;
        main__Node* right;
};
...
VV_LOCAL_SYMBOL void main__main(void) {
        main__Node n = ((main__Node){.val = 123,.left = 0,.right = 0,});
        println(str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s=main__Node_str(*n.left)}}})));
}
...
```

So yeah, we're able to create a null pointer (V reference) with no compiler errors or warnings.

*Evaluation*: ðŸ›‘ Doesn't seem to hold up

> No undefined values

It's not obvious to me what this means.
Javascript has a [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) value but that doesn't really seem relevant.
C allows you to use an uninitialized variable which can result in Undefined Behavior.
I'll assume that's what this means.

Typically, uninitalized values come from a memory allocation that hasn't been written to.
Let's see if we can get the V compiler to allocate memory for us without writting to it:

```v
fn main() {
        a := []&int { len: 1 }
        println(a)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.926306498470184027.tmp.c:6770: at print_backtrace: Backtrace
/tmp/v_1000/test.926306498470184027.tmp.c:6841: by v_segmentation_fault_handler
7fc58f7fd210 : by ???
/tmp/v_1000/test.926306498470184027.tmp.c:1973: by Array_main__Node_ptr_str
/tmp/v_1000/test.926306498470184027.tmp.c:11644: by main__main
/tmp/v_1000/test.926306498470184027.tmp.c:12010: by main
```

Sigh.
The generated C code is 12,000 lines long and nothing jumps out to me with a quick glance, so I won't try to dig in further. 

*Evaluation*: ðŸ›‘ Doesn't seem to hold up

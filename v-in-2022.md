# V Review (2022)

[V](https://vlang.io/) is a programming language promising to be "Simple, fast, safe, compiled. For developing maintainable software.".
V has a [controversial](https://christine.website/blog/v-vaporware-2019-06-23) [past](https://christine.website/blog/v-vvork-in-progress-2020-01-03) but what is the state of V in 2022?

Is V worth checking out? 

In this post, we'll take a look at V as it exists in May 2022. 

## Rules of engagement

I'll be using the current version of V built from git which is [`50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6`](https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6).
I'll also stick to the compiler defaults as much as possible to keep to the ["happy path"](https://en.wikipedia.org/wiki/Happy_path) so that I get a typical V experience.

To evaluate the language, I'll validate the claims made on their homepage and related sub-pages/documentation.
Features indicated to be incomplete/work in progress/unimplemented will be mentioned as such.
Where possible, I'll try to include the code used to evalute a claim.

## Evaluation

### Simple language for building maintainable programs

I don't see any objective way to evaluate the claims in this section, so we'll give them a pass.

*Evaluation*: N/a

### Safety

> No null

The [V docs](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md) indicate V has references and "in general, V's references are similar to Go pointers and C++ references".

Let's see if we can pass a null reference to a function.
The docs contain an example of a tree structure, so let's adapt that and see if we can create a null reference.
Null usually corresponds to `0` so we'll try that:

```v
struct Node {
        val   int
        left  &Node
        right &Node
}

fn main() {
        n := Node { 123, 0, 0 }
        println(n.left)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.2938032035736349851.tmp.c:6750: at print_backtrace: Backtrace
/tmp/v_1000/test.2938032035736349851.tmp.c:6821: by v_segmentation_fault_handler
7f6ff9bfe210 : by ???
/tmp/v_1000/test.2938032035736349851.tmp.c:11990: by main
```

Oh, no. 😰
Let's check the generated C and *see* what's up:

```c
...
struct main__Node {
        int val;
        main__Node* left;
        main__Node* right;
};
...
VV_LOCAL_SYMBOL void main__main(void) {
        main__Node n = ((main__Node){.val = 123,.left = 0,.right = 0,});
        println(str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s=main__Node_str(*n.left)}}})));
}
...
```

So yeah, we're able to create a null pointer (V reference) with no compiler errors or warnings.

*Evaluation*: 🛑 Doesn't seem to hold up

> No undefined values

It's not obvious to me what this means.
Javascript has a [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) value but that doesn't really seem relevant.
C allows you to use an uninitialized variable which can result in Undefined Behavior.
I'll assume that's what this means.

Typically, uninitalized values come from a memory allocation that hasn't been written to.
The [V docs say](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md#array-initialization) we can create an empty array by passing the allocation length in the initialization expression.
Let's see if we can get the V compiler to allocate memory for us without writting to it:

```v
fn main() {
        a := []&int { len: 1 }
        println(a)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.926306498470184027.tmp.c:6770: at print_backtrace: Backtrace
/tmp/v_1000/test.926306498470184027.tmp.c:6841: by v_segmentation_fault_handler
7fc58f7fd210 : by ???
/tmp/v_1000/test.926306498470184027.tmp.c:1973: by Array_main__Node_ptr_str
/tmp/v_1000/test.926306498470184027.tmp.c:11644: by main__main
/tmp/v_1000/test.926306498470184027.tmp.c:12010: by main
```

Sigh.
The generated C code is 12,000 lines long and nothing jumps out to me with a quick glance, so I won't try to dig in further. 

*Evaluation*: 🛑 Doesn't seem to hold up

> No undefined behavior

Wikipedia [has a list](https://en.wikipedia.org/wiki/Undefined_behavior#Examples_in_C_and_C++) of Undefined Behaviors (UB) in C and C++.
Let's see if we can get V to generate C code which contains some of these behaviors!

- Integer Overflow

In C and C++, signed integer overflow results in UB.
Let's try to add `1` to the max value of an integer and see what happens:

```v
fn main() {
        x := i32(2147483647) + 1
        println(x)
}
```

```
$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
test.c: In function ‘main__main’:
test.c:11605:30: warning: integer overflow in expression of type ‘int’ results in ‘-2147483648’ [-Woverflow]
11605 |  int x = ((i32)(2147483647)) + 1;
      |                              ^
$ ./a.out
test.c:7248:33: runtime error: signed integer overflow: -2147483648 - 2147483600 cannot be represented in type 'int'
-2147483648
```

That's no good.

Let's try some of the other classic cases of UB.

- Divide by 0

```v
fn main() {
        x := 42
        y := 0
        z := x / y
        println(z)
}
```

```
$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
$ ./a.out
test.c:11607:12: runtime error: division by zero
Floating point exception
```

- Temporal memory safety violations (dangling pointer)

```v
struct Something {
        val   int
}

fn main() {
        x := voidptr(123)
        y := &Something(x)
        println(y)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.5460990319614516137.tmp.c:6746: at print_backtrace: Backtrace
/tmp/v_1000/test.5460990319614516137.tmp.c:6817: by v_segmentation_fault_handler
7f062f88d210 : by ???
/tmp/v_1000/test.5460990319614516137.tmp.c:11987: by main
```

There's more UB we could test for but I'm just going to call it there.

*Evaluation*: 🛑 Doesn't seem to hold up

> No variable shadowing

I don't see how variable shadowing is a safety issue and shadowing variables after they should no longer be used in a common technique in functional programming languages but let's test it out:

```v
fn main() {
        x := 1
        x := 2

        if true {
                x := 3
        }
}
```

```
$ ./v run test.v
test.v:3:2: error: redefinition of `x`
    1 | fn main() {
    2 |     x := 1
    3 |     x := 2
      |     ^
    4 |
    5 |     if true {
```

and removing that line:

```
$ ./v run test.v
test.v:5:3: error: redefinition of `x`
    3 |
    4 |     if true {
    5 |         x := 3
      |         ^
    6 |     }
    7 | }
```

Works as advertised! ✔️

I see though that V supports closures.
What are the rules for shadowing variables in closures?

```v
fn main() {
        x := 1

        y := fn (x int) {
                println(x)
        }

        y(x)
        y(2)
}
```

```
$ ./v run test.v
1
2
```

It looks like shadowing is allowed for closure arguments? 
There are also explicit closure captures, what happens if I also capture `x`?

```v
$ cat test.v
fn main() {
        x := 1

        y := fn [x] (x int) {
                println(x)
        }

        y(x)
        y(2)
}
```

```
$ ./v run test.v
1
1
```

Well, that seems like it should be disallowed.
It makes sense that `x` can be captured but to then shadow the argument with the same name without error or warning doesn't seem inline with the rest of V's behavior.

Even with this surprising behavior, I'm going to give it to V.

*Evaluation*: ✔️ Seems to work

> Bounds checking

Bounds checking is important to prevent out-of-bounds access to arrays.

Let's check a simple example:

```v
fn main() {
        x := [1, 2, 3]
        println(x[4])
}
```

```
$ ./v run test.v
V panic: array.get: index out of range (i == 4, a.len == 3)
v hash: 50ab2cf
/tmp/v_1000/test.17032083146791375427.tmp.c:6344: at _v_panic: Backtrace
/tmp/v_1000/test.17032083146791375427.tmp.c:5860: by array_get
/tmp/v_1000/test.17032083146791375427.tmp.c:11597: by main__main
/tmp/v_1000/test.17032083146791375427.tmp.c:11963: by main
```

Seeing `a.len == 3` reminds me that V allows you to mess with some of the array (vector) properties at creation:

```v
fn main() {
        x := []&int { len: 10, cap: 0 }
        println(x[4])
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.8104236387804386445.tmp.c:6724: at print_backtrace: Backtrace
/tmp/v_1000/test.8104236387804386445.tmp.c:6795: by v_segmentation_fault_handler
7f8aa2432210 : by ???
/tmp/v_1000/test.8104236387804386445.tmp.c:11964: by main
```

Allowing the user to control the `len` property is a **really** bad idea.

*Evaluation*: ⚠️ Some basic checking exists but can be trivially bypassed

> Immutable variables by default

Immutable values by default is a good default in a modern programming language.

```v
fn main() {
        x := 4
        x = 2
}
```

```
$ ./v run test.v
test.v:2:2: warning: unused variable: `x`
    1 | fn main() {
    2 |     x := 4
      |     ^
    3 |     x = 2
    4 | }
test.v:3:2: error: `x` is immutable, declare it with `mut` to make it mutable
    1 | fn main() {
    2 |     x := 4
    3 |     x = 2
      |     ^
    4 | }
```

So far so good!
V seems to be pretty loose with typecasts though so can we trick the compiler into letting us mutate an immutable value?
Yes, we can:

```v
[heap]
struct Foo {
        mut: value int
}

fn y(x &Foo) {
        mut m := x
        m.value = 42
}

fn main() {
        x := Foo { 123 }
        y(x)
        println(x)
}
```

```
$ ./v run test.v
Foo{
    value: 42
}
```

You really shouldn't be able to convert the immutable reference to a mutable one (`mut m := x`).
This results in us being able to mutate the "immutable" value `x` in `main` with no indication at the call site, there's not even the clue that we're passing the value by reference.

*Evaluation*: 🛑 Variables aren't immutable in any significant way because you can trivially turn an immutable reference into a mutable one.


# V Review (2022)

[V](https://vlang.io/) is a programming language promising to be "Simple, fast, safe, compiled. For developing maintainable software.".
V has a [controversial](https://christine.website/blog/v-vaporware-2019-06-23) [past](https://christine.website/blog/v-vvork-in-progress-2020-01-03) but what is the state of V in 2022?

Is V worth checking out? 

In this post, we'll take a look at V as it exists in May 2022. 

## Rules of engagement

I'll be using the current version of V built from git which is [`50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6`](https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6).
I'll also stick to the compiler defaults as much as possible to keep to the ["happy path"](https://en.wikipedia.org/wiki/Happy_path) so that I get a typical V experience.

To evaluate the language, I'll validate the claims made on their homepage and related sub-pages/documentation.
Features indicated to be incomplete/work in progress/unimplemented will be mentioned as such.
Where possible, I'll try to include the code used to evalute a claim.

## Evaluation

### Simple language for building maintainable programs

I don't see any objective way to evaluate the claims in this section, so we'll give them a pass.

*Evaluation*: N/a

### Safety

> No null

The [V docs](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md) indicate V has references and "in general, V's references are similar to Go pointers and C++ references".

Let's see if we can pass a null reference to a function.
The docs contain an example of a tree structure, so let's adapt that and see if we can create a null reference.
Null usually corresponds to `0` so we'll try that:

```v
struct Node {
        val   int
        left  &Node
        right &Node
}

fn main() {
        n := Node { 123, 0, 0 }
        println(n.left)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.2938032035736349851.tmp.c:6750: at print_backtrace: Backtrace
/tmp/v_1000/test.2938032035736349851.tmp.c:6821: by v_segmentation_fault_handler
7f6ff9bfe210 : by ???
/tmp/v_1000/test.2938032035736349851.tmp.c:11990: by main
```

Oh, no. ðŸ˜°
Let's check the generated C and *see* what's up:

```c
...
struct main__Node {
        int val;
        main__Node* left;
        main__Node* right;
};
...
VV_LOCAL_SYMBOL void main__main(void) {
        main__Node n = ((main__Node){.val = 123,.left = 0,.right = 0,});
        println(str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s=main__Node_str(*n.left)}}})));
}
...
```

So yeah, we're able to create a null pointer (V reference) with no compiler errors or warnings.

*Evaluation*: ðŸ›‘ Doesn't seem to hold up

> No undefined values

It's not obvious to me what this means.
Javascript has a [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) value but that doesn't really seem relevant.
C allows you to use an uninitialized variable which can result in Undefined Behavior.
I'll assume that's what this means.

Typically, uninitalized values come from a memory allocation that hasn't been written to.
The [V docs say](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md#array-initialization) we can create an empty array by passing the allocation length in the initialization expression.
Let's see if we can get the V compiler to allocate memory for us without writting to it:

```v
fn main() {
        a := []&int { len: 1 }
        println(a)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.926306498470184027.tmp.c:6770: at print_backtrace: Backtrace
/tmp/v_1000/test.926306498470184027.tmp.c:6841: by v_segmentation_fault_handler
7fc58f7fd210 : by ???
/tmp/v_1000/test.926306498470184027.tmp.c:1973: by Array_main__Node_ptr_str
/tmp/v_1000/test.926306498470184027.tmp.c:11644: by main__main
/tmp/v_1000/test.926306498470184027.tmp.c:12010: by main
```

Sigh.
The generated C code is 12,000 lines long and nothing jumps out to me with a quick glance, so I won't try to dig in further. 

*Evaluation*: ðŸ›‘ Doesn't seem to hold up

> No undefined behavior

Wikipedia [has a list](https://en.wikipedia.org/wiki/Undefined_behavior#Examples_in_C_and_C++) of Undefined Behaviors (UB) in C and C++.
Let's see if we can get V to generate C code which contains some of these behaviors!

- Integer Overflow

In C and C++, signed integer overflow results in UB.
Let's try to add `1` to the max value of an integer and see what happens:

```v
fn main() {
        x := i32(2147483647) + 1
        println(x)
}
```

```
$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
test.c: In function â€˜main__mainâ€™:
test.c:11605:30: warning: integer overflow in expression of type â€˜intâ€™ results in â€˜-2147483648â€™ [-Woverflow]
11605 |  int x = ((i32)(2147483647)) + 1;
      |                              ^
$ ./a.out
test.c:7248:33: runtime error: signed integer overflow: -2147483648 - 2147483600 cannot be represented in type 'int'
-2147483648
```

That's no good.

Let's try some of the other classic cases of UB.

- Divide by 0

```v
fn main() {
        x := 42
        y := 0
        z := x / y
        println(z)
}
```

```
$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
$ ./a.out
test.c:11607:12: runtime error: division by zero
Floating point exception
```

- Temporal memory safety violations (dangling pointer)

```v
struct Something {
        val   int
}

fn main() {
        x := voidptr(123)
        y := &Something(x)
        println(y)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.5460990319614516137.tmp.c:6746: at print_backtrace: Backtrace
/tmp/v_1000/test.5460990319614516137.tmp.c:6817: by v_segmentation_fault_handler
7f062f88d210 : by ???
/tmp/v_1000/test.5460990319614516137.tmp.c:11987: by main
```

There's more UB we could test for but I'm just going to call it there.

*Evaluation*: ðŸ›‘ Doesn't seem to hold up


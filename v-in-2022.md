# V Review (2022)

[V](https://vlang.io/) is a programming language promising to be "Simple, fast, safe, compiled. For developing maintainable software.".
V has a [controversial](https://christine.website/blog/v-vaporware-2019-06-23) [past](https://christine.website/blog/v-vvork-in-progress-2020-01-03) but what is the state of V in 2022?

Is V worth checking out? 

In this post, we'll take a look at V as it exists in May 2022. 

## Rules of engagement

I'll be using the current version of V built from git which is [`50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6`](https://github.com/vlang/v/tree/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6).
I'll also stick to the compiler defaults as much as possible to keep to the ["happy path"](https://en.wikipedia.org/wiki/Happy_path) so that I get a typical V experience.

To evaluate the language, I'll validate the claims made on their homepage and related sub-pages/documentation.
Features indicated to be incomplete/work in progress/unimplemented will be mentioned as such.
Where possible, I'll try to include the code used to evalute a claim.

## Evaluation

### Simple language for building maintainable programs

I don't see any objective way to evaluate the claims in this section, so we'll give them a pass.

*Evaluation*: N/a

### Safety

> No null

The [V docs](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md) indicate V has references and "in general, V's references are similar to Go pointers and C++ references".

Let's see if we can pass a null reference to a function.
The docs contain an example of a tree structure, so let's adapt that and see if we can create a null reference.
Null usually corresponds to `0` so we'll try that:

```v
struct Node {
    val   int
    left  &Node
    right &Node
}

fn main() {
    n := Node { 123, 0, 0 }
    println(n.left)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.2938032035736349851.tmp.c:6750: at print_backtrace: Backtrace
/tmp/v_1000/test.2938032035736349851.tmp.c:6821: by v_segmentation_fault_handler
7f6ff9bfe210 : by ???
/tmp/v_1000/test.2938032035736349851.tmp.c:11990: by main
```

Oh, no. 😰
Let's check the generated C and *see* what's up:

```c
...
struct main__Node {
    int val;
    main__Node* left;
    main__Node* right;
};
...
VV_LOCAL_SYMBOL void main__main(void) {
    main__Node n = ((main__Node){.val = 123,.left = 0,.right = 0,});
    println(str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s=main__Node_str(*n.left)}}})));
}
...
```

So yeah, we're able to create a null pointer (V reference) with no compiler errors or warnings.

*Evaluation*: 🛑 Doesn't seem to hold up

> No undefined values

It's not obvious to me what this means.
Javascript has a [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) value but that doesn't really seem relevant.
C allows you to use an uninitialized variable which can result in Undefined Behavior.
I'll assume that's what this means.

Typically, uninitalized values come from a memory allocation that hasn't been written to.
The [V docs say](https://github.com/vlang/v/blob/50ab2cfd1ae02d4f4280f38c60b8dbd17f7599f6/doc/docs.md#array-initialization) we can create an empty array by passing the allocation length in the initialization expression.
Let's see if we can get the V compiler to allocate memory for us without writting to it:

```v
fn main() {
    a := []&int { len: 1 }
    println(a)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.926306498470184027.tmp.c:6770: at print_backtrace: Backtrace
/tmp/v_1000/test.926306498470184027.tmp.c:6841: by v_segmentation_fault_handler
7fc58f7fd210 : by ???
/tmp/v_1000/test.926306498470184027.tmp.c:1973: by Array_main__Node_ptr_str
/tmp/v_1000/test.926306498470184027.tmp.c:11644: by main__main
/tmp/v_1000/test.926306498470184027.tmp.c:12010: by main
```

Sigh.
The generated C code is 12,000 lines long and nothing jumps out to me with a quick glance, so I won't try to dig in further. 

*Evaluation*: 🛑 Doesn't seem to hold up

> No undefined behavior

Wikipedia [has a list](https://en.wikipedia.org/wiki/Undefined_behavior#Examples_in_C_and_C++) of Undefined Behaviors (UB) in C and C++.
Let's see if we can get V to generate C code which contains some of these behaviors!

- Integer Overflow

In C and C++, signed integer overflow results in UB.
Let's try to add `1` to the max value of an integer and see what happens:

```v
fn main() {
    x := i32(2147483647) + 1
    println(x)
}
```

```
$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
test.c: In function ‘main__main’:
test.c:11605:30: warning: integer overflow in expression of type ‘int’ results in ‘-2147483648’ [-Woverflow]
11605 |  int x = ((i32)(2147483647)) + 1;
      |                              ^
$ ./a.out
test.c:7248:33: runtime error: signed integer overflow: -2147483648 - 2147483600 cannot be represented in type 'int'
-2147483648
```

That's no good.

Let's try some of the other classic cases of UB.

- Divide by 0

```v
fn main() {
    x := 42
    y := 0
    z := x / y
    println(z)
}
```

```
$ ./v -o test.c test.v
$ cc -fsanitize=undefined test.c
$ ./a.out
test.c:11607:12: runtime error: division by zero
Floating point exception
```

- Temporal memory safety violations (dangling pointer)

```v
struct Something {
    val   int
}

fn main() {
    x := voidptr(123)
    y := &Something(x)
    println(y)
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.5460990319614516137.tmp.c:6746: at print_backtrace: Backtrace
/tmp/v_1000/test.5460990319614516137.tmp.c:6817: by v_segmentation_fault_handler
7f062f88d210 : by ???
/tmp/v_1000/test.5460990319614516137.tmp.c:11987: by main
```

There's more UB we could test for but I'm just going to call it there.

*Evaluation*: 🛑 Doesn't seem to hold up

> No variable shadowing

I don't see how variable shadowing is a safety issue and shadowing variables after they should no longer be used in a common technique in functional programming languages but let's test it out:

```v
fn main() {
    x := 1
    x := 2

    if true {
        x := 3
    }
}
```

```
$ ./v run test.v
test.v:3:2: error: redefinition of `x`
    1 | fn main() {
    2 |     x := 1
    3 |     x := 2
      |     ^
    4 |
    5 |     if true {
```

and removing that line:

```
$ ./v run test.v
test.v:5:3: error: redefinition of `x`
    3 |
    4 |     if true {
    5 |         x := 3
      |         ^
    6 |     }
    7 | }
```

Works as advertised! ✔️

I see though that V supports closures.
What are the rules for shadowing variables in closures?

```v
fn main() {
    x := 1

    y := fn (x int) {
        println(x)
    }

    y(x)
    y(2)
}
```

```
$ ./v run test.v
1
2
```

It looks like shadowing is allowed for closure arguments? 
There are also explicit closure captures, what happens if I also capture `x`?

```v
$ cat test.v
fn main() {
    x := 1

    y := fn [x] (x int) {
        println(x)
    }

    y(x)
    y(2)
}
```

```
$ ./v run test.v
1
1
```

Well, that seems like it should be disallowed.
It makes sense that `x` can be captured but to then shadow the argument with the same name without error or warning doesn't seem inline with the rest of V's behavior.

Even with this surprising behavior, I'm going to give it to V.

*Evaluation*: ✔️ Seems to work

> Bounds checking

Bounds checking is important to prevent out-of-bounds access to arrays.

Let's check a simple example:

```v
fn main() {
    x := [1, 2, 3]
    println(x[4])
}
```

```
$ ./v run test.v
V panic: array.get: index out of range (i == 4, a.len == 3)
v hash: 50ab2cf
/tmp/v_1000/test.17032083146791375427.tmp.c:6344: at _v_panic: Backtrace
/tmp/v_1000/test.17032083146791375427.tmp.c:5860: by array_get
/tmp/v_1000/test.17032083146791375427.tmp.c:11597: by main__main
/tmp/v_1000/test.17032083146791375427.tmp.c:11963: by main
```

Seeing `a.len == 3` reminds me that V allows you to mess with some of the array (vector) properties at creation:

```v
fn main() {
    x := []&int { len: 10, cap: 0 }
    println(x[4])
}
```

```
$ ./v run test.v
signal 11: segmentation fault
/tmp/v_1000/test.8104236387804386445.tmp.c:6724: at print_backtrace: Backtrace
/tmp/v_1000/test.8104236387804386445.tmp.c:6795: by v_segmentation_fault_handler
7f8aa2432210 : by ???
/tmp/v_1000/test.8104236387804386445.tmp.c:11964: by main
```

Allowing the user to control the `len` property is a **really** bad idea.

*Evaluation*: ⚠️ Some basic checking exists but can be trivially bypassed

> Immutable variables by default

Immutable values by default is a good default in a modern programming language.

```v
fn main() {
    x := 4
    x = 2
}
```

```
$ ./v run test.v
test.v:2:2: warning: unused variable: `x`
    1 | fn main() {
    2 |     x := 4
      |     ^
    3 |     x = 2
    4 | }
test.v:3:2: error: `x` is immutable, declare it with `mut` to make it mutable
    1 | fn main() {
    2 |     x := 4
    3 |     x = 2
      |     ^
    4 | }
```

So far so good!
V seems to be pretty loose with typecasts though so can we trick the compiler into letting us mutate an immutable value?
Yes, we can:

```v
[heap]
struct Foo {
    mut: value int
}

fn y(x &Foo) {
    mut m := x
    m.value = 42
}

fn main() {
    x := Foo { 123 }
    y(x)
    println(x)
}
```

```
$ ./v run test.v
Foo{
    value: 42
}
```

You really shouldn't be able to convert the immutable reference to a mutable one (`mut m := x`).
This results in us being able to mutate the "immutable" value `x` in `main` with no indication at the call site, there's not even the clue that we're passing the value by reference.

*Evaluation*: 🛑 Variables aren't immutable in any significant way because you can trivially turn an immutable reference into a mutable one.

> Pure functions by default

The [docs say](https://github.com/vlang/v/blob/master/doc/docs.md#pure-functions-by-default):

> V functions are pure by default, meaning that their return values are a function of their arguments only, and their evaluation has no side effects (besides I/O).

**besides I/O**

[wat](https://www.destroyallsoftware.com/talks/wat)

I/O is [literally the definition of an impure operation](https://en.wikipedia.org/wiki/Pure_function#I/O_in_pure_functions) because it allows a function to trivially break referential transparency which V claims to uphold ("their {V functions} return values are a function of their arguments only").

> This is achieved by a lack of global variables and all function arguments being immutable by default, even when references are passed.

As we saw in the previous section, immutability in V is broken so this guarantee doesn't hold.

To demonstrate how completely ludicrous this definition is, here is a "pure" V module that re-implements global variables using file I/O:

```v
import os

fn read_global(name string) int {
    content := os.read_file(name) or { return 0 }
    return content.int()
}

fn write_global(name string, value int) {
    s := value.str()
    os.write_file(name, s) or { }
}
```

and we'll go ahead and use it:

```v
import globals

fn x() {
    globals.write_global("my_global", 7)
}

fn y() {
    my_global := globals.read_global("my_global")
    globals.write_global("my_global", my_global * 3)
}

fn z() int {
    my_global := globals.read_global("my_global")
    globals.write_global("my_global", my_global * 2)
    return globals.read_global("my_global")
}

fn main() {
    x()
    y()
    my_global := z()
    println(my_global)
}
```

```
$ ./v run test.v
42
```

*Evaluation*: 🛑 Claim is meaningless as it redefines "pure" to mean "impure"

> Immutable structs by default

We've already broke immutable values in a previous section using structs so we know this doesn't hold.

*Evaluation*: 🛑 Doesn't seem to hold

> Option/Result and mandatory error checks

Mandatory error checks seem to work correctly in most contexts.
Is it possible to confuse the compiler and have it ignore the return value?

```v
fn ignore(x any) {
}

fn create_error() ?int {
    return error("an error")
}

fn main() {
    ignore(create_error())
}
```

```
$ ./v run test.v
test.v:9:9: error: create_error() returns an option, so it should have either an `or {}` block, or `?` at the end
    7 |
    8 | fn main() {
    9 |     ignore(create_error())
      |            ~~~~~~~~~~~~~~
   10 | }
```

Looks good! 
I tried a few different variations on this idea but wasn't able to confuse the compiler.

*Evaluation*: ✔️ Works as advertised

> Sum types

Sum types are a very nice feature!
Let's see how they work:

```v
type MyType = f64 | i64

fn test(x MyType) {
        println(x)
}

fn main() {
        test(i64(0))
}
```

```
$ ./v run test.v
MyType(0)
```

Good!
The implementation seems pretty fragile though.
Many operations that are allowed for normal types, seem to crash the compiler when used with sumtypes.
For instance, casting:

```v
type MyType = f64 | i64

fn test(x MyType) {
        println(i64(x))
}

fn main() {
        test(i64(0))
}
```

```
$ ./v run test.v
==================
/tmp/v_1000/test.11297848884384464859.tmp.c:11633: error: cannot convert 'struct main__MyType' to 'long'
...
==================
(Use `v -cg` to print the entire error message)

builder error:
==================
C error. This should never happen.

This is a compiler bug, please report it using `v bug file.v`.

https://github.com/vlang/v/issues/new/choose

You can also use #help on Discord: https://discord.gg/vlang
```

Sum types have some restrictions:

```v
type MyType = &i64 | &f64

fn main() {
}
```

```
$ ./v run test.v
test.v:1:15: error: sum type cannot hold a reference type
    1 | type MyType = &i64 | &f64
      |               ~~~~
    2 |
    3 | fn main() {
```

but they don't seem to be well checked 😢:

```v
type MyType = Foo | Bar
type Foo = &i64
type Bar = &f64

fn main() {
}
```

```
$ ./v run test.v
$ echo $?
0
```

*Evaluation*: ⚠️ Sum types generally seem to work but there are implementation issues.
